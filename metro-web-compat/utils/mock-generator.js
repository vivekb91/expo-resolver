const fs = require('fs');
const path = require('path');
const { logger } = require('./logger');
const { getMobilePackageCategory } = require('../src/pattern-detector');

const MOCK_TEMPLATES = {
  expo: {
    defaultExport: true,
    warningMessage: 'Expo module not available on web platform',
    mockType: 'graceful'
  },
  'react-native': {
    defaultExport: false,
    warningMessage: 'React Native module not available on web platform',
    mockType: 'graceful'
  },
  'react-native-community': {
    defaultExport: false,
    warningMessage: 'React Native Community module not available on web platform',
    mockType: 'graceful'
  },
  'react-navigation': {
    defaultExport: false,
    warningMessage: 'React Navigation module may need web-specific implementation',
    mockType: 'placeholder'
  },
  'third-party': {
    defaultExport: true,
    warningMessage: 'Third-party mobile module not available on web platform',
    mockType: 'placeholder'
  }
};

function generateMockContent(moduleName, category, options = {}) {
  const template = MOCK_TEMPLATES[category] || MOCK_TEMPLATES['third-party'];
  const { mockType, warningMessage, defaultExport } = template;
  
  const mockName = moduleName.split('/').pop().replace(/[^a-zA-Z0-9]/g, '');
  const className = mockName.charAt(0).toUpperCase() + mockName.slice(1);
  
  let mockImplementation = '';
  
  switch (mockType) {
    case 'graceful':
      mockImplementation = generateGracefulMock(moduleName, className, warningMessage);
      break;
    case 'placeholder':
      mockImplementation = generatePlaceholderMock(moduleName, className, warningMessage);
      break;
    default:
      mockImplementation = generateBasicMock(moduleName, className, warningMessage);
  }
  
  const exportType = defaultExport ? 'export default' : 'module.exports =';
  
  return `/**
 * Auto-generated web compatibility mock for ${moduleName}
 * Generated by metro-web-compat
 * 
 * This mock provides basic compatibility for web platforms.
 * For full functionality, consider using a web-specific alternative.
 */

${mockImplementation}

${exportType} ${className}Mock;
`;
}

function generateGracefulMock(moduleName, className, warningMessage) {
  return `
const ${className}Mock = new Proxy({}, {
  get(target, prop) {
    if (prop === 'toString') {
      return () => '[Mock ${moduleName}]';
    }
    
    if (prop === 'default') {
      return ${className}Mock;
    }
    
    if (typeof prop === 'string' && !prop.startsWith('_')) {
      console.warn('${warningMessage}: Accessing property "' + prop + '"');
      
      // Return a function that warns when called
      return function(...args) {
        console.warn('${warningMessage}: Called method "' + prop + '" with args:', args);
        return Promise.resolve(null);
      };
    }
    
    return undefined;
  }
});`;
}

function generatePlaceholderMock(moduleName, className, warningMessage) {
  return `
const ${className}Mock = {
  __isMock: true,
  __originalModule: '${moduleName}',
  
  toString() {
    return '[Mock ${moduleName}]';
  },
  
  // Common method stubs
  initialize: () => {
    console.warn('${warningMessage}');
    return Promise.resolve();
  },
  
  configure: (config) => {
    console.warn('${warningMessage}');
    return Promise.resolve();
  },
  
  isAvailable: () => {
    return Promise.resolve(false);
  }
};`;
}

function generateBasicMock(moduleName, className, warningMessage) {
  return `
const ${className}Mock = {
  __isMock: true,
  __originalModule: '${moduleName}',
  
  toString() {
    return '[Mock ${moduleName}]';
  }
};

console.warn('${warningMessage}');`;
}

function generateAutoMock(moduleName, context, options = {}) {
  const category = getMobilePackageCategory(moduleName);
  const mockFileName = `${moduleName.replace(/[^a-zA-Z0-9]/g, '-')}.js`;
  const mockDir = path.join(__dirname, '..', 'mocks', 'auto-generated');
  const mockPath = path.join(mockDir, mockFileName);
  
  try {
    // Ensure mock directory exists
    if (!fs.existsSync(mockDir)) {
      fs.mkdirSync(mockDir, { recursive: true });
    }
    
    // Check if mock already exists
    if (fs.existsSync(mockPath)) {
      logger.debug(`Using existing auto-generated mock for ${moduleName}`);
      return mockPath;
    }
    
    // Generate mock content
    const mockContent = generateMockContent(moduleName, category, options);
    
    // Write mock file
    fs.writeFileSync(mockPath, mockContent, 'utf8');
    
    logger.info(`Generated auto-mock for ${moduleName} at ${mockPath}`);
    
    return mockPath;
    
  } catch (error) {
    logger.error(`Failed to generate auto-mock for ${moduleName}:`, error.message);
    
    // Fallback to inline mock
    return generateInlineMock(moduleName, category);
  }
}

function generateInlineMock(moduleName, category) {
  const template = MOCK_TEMPLATES[category] || MOCK_TEMPLATES['third-party'];
  const { warningMessage } = template;
  
  // Return a simple inline mock object
  return {
    __isMock: true,
    __originalModule: moduleName,
    toString: () => `[Mock ${moduleName}]`,
    [Symbol.toPrimitive]: () => `[Mock ${moduleName}]`,
    default: function() {
      console.warn(warningMessage);
      return null;
    }
  };
}

function cleanupAutoGeneratedMocks(maxAge = 24 * 60 * 60 * 1000) { // 24 hours
  const mockDir = path.join(__dirname, '..', 'mocks', 'auto-generated');
  
  if (!fs.existsSync(mockDir)) {
    return;
  }
  
  try {
    const files = fs.readdirSync(mockDir);
    const now = Date.now();
    
    files.forEach(file => {
      const filePath = path.join(mockDir, file);
      const stats = fs.statSync(filePath);
      
      if (now - stats.mtime.getTime() > maxAge) {
        fs.unlinkSync(filePath);
        logger.debug(`Cleaned up old auto-generated mock: ${file}`);
      }
    });
  } catch (error) {
    logger.error('Failed to cleanup auto-generated mocks:', error.message);
  }
}

function getMockInfo(moduleName) {
  const category = getMobilePackageCategory(moduleName);
  const template = MOCK_TEMPLATES[category] || MOCK_TEMPLATES['third-party'];
  
  return {
    category,
    mockType: template.mockType,
    warningMessage: template.warningMessage,
    defaultExport: template.defaultExport
  };
}

module.exports = {
  generateAutoMock,
  generateMockContent,
  cleanupAutoGeneratedMocks,
  getMockInfo,
  MOCK_TEMPLATES
};